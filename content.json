{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Apollo","url":"http://www.irisnote.xyz","root":"/"},"pages":[{"title":"[404]","date":"2025-03-25T01:33:34.775Z","updated":"2025-03-25T01:33:34.775Z","comments":true,"path":"404.html","permalink":"http://www.irisnote.xyz/404.html","excerpt":"","text":""},{"title":"about","date":"2025-03-25T01:05:16.000Z","updated":"2025-03-25T01:06:41.627Z","comments":true,"path":"about/index.html","permalink":"http://www.irisnote.xyz/about/index.html","excerpt":"","text":"Here is Apollo’s blog."}],"posts":[{"title":"mulNICtl user manual","slug":"User-Manual","date":"2025-03-23T16:00:00.000Z","updated":"2025-03-25T01:51:30.139Z","comments":true,"path":"2025/03/24/User-Manual/","permalink":"http://www.irisnote.xyz/2025/03/24/User-Manual/","excerpt":"","text":"1. 项目总览mulNICtl 是一个多网络接口控制与传输实验工具，支持网络拓扑配置、数据流传输模拟以及实时监控与调度。项目目录结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172.├── config│ ├── stream│ │ └── ...│ └── topo │ └── ...├── config_all.py├── install.py├── manifest.json├── mulNICtl.py├── requirements.txt├── run_exp.py├── solver/src│ ├── api│ │ └── ...│ ├── core│ │ └── ...│ ├── types│ │ └── ...│ ├── tests│ │ └── ...├── stream-replay│ ├── android │ │ └── ...│ ├── Cargo.lock│ ├── Cargo.toml│ ├── core│ │ └── ...│ ├── data│ │ └── ...│ ├── log│ │ └── ...│ ├── logs│ │ └── ...│ ├── manifest.json.example│ ├── previews│ │ └── ...│ ├── README.md│ ├── rx│ │ └── ...│ ├── tx│ │ └── ...│ └── udp_rx.py├── sync_all.py├── tap.py├── tools│ ├── create_data.py│ ├── create_STA.py│ ├── file_rx.py│ ├── file_tx.py│ ├── get_channel.py│ ├── __init__.py│ ├── ip_extract.py│ ├── read_graph.py│ ├── read_mcs.py│ ├── read_rtt.py│ └── set_route.py├── util│ ├── api│ │ ├── __init__.py│ │ └── ipc.py│ ├── constHead.py│ ├── ctl.py│ ├── ifSense.py│ ├── __init__.py│ ├── logger.py│ ├── predictor.py│ ├── qos.py│ ├── solver.py│ ├── stream.py│ └── trans_graph.py└── warmup.py 项目架构图： 2. Requirements 项目需要3.10及以上版本的python解释器。相关python依赖可以通过以下指令配置： 1pip3 install -r requirements.txt 项目需要rust环境来编译构建stream-replay 工具。相关环境可以通过以下指令配置： 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh stream-replay是用来进行流量传输模拟的工具，在配置好rust环境后可以通过以下指令编译： 12cd stream-replaycargo build --release 3. Monitor端3.1 功能monitor端是实验的总控制端，主要功能包括： 对模拟传输实验进行总体调度，配置干扰流，数据流等参数 接收，存储回传来自Solver的统计数据并进行可视化处理(可选) 3.2 用法为了便于说明，我们把两个设备之间的链路记作两个设备无线接口名的元组，例如 (&#39;wlan0&#39;, &#39;wlan1&#39;), 这样的无线接口名可以通过在设备命令行输入 iw dev 来查看. NOTICE: 以下操作应在项目根目录进行. 设置 monitor 监控端： 1python3 tap.py -s 终端会列出所有连接的设备，此时可以对照具体设备配置进行连接检查 设置自定义名称的用户设备，例如设置设备 STA1： 1python3 tap.py -c 192.168.3.72 -n STA1 在config&#x2F;topo下新建并编写&#39;&#123;date&#125;.txt&#39;文件来表示网络拓扑。每个链路占据一行，格式如下： 1STA1 --wlan0-- --wlan1-- STA2 其中--wlan0-- --wlan1--是STA1和STA2之间的链路，含义已在上面介绍 monitor端的基本配置已经完成，用户可以在expSrc下新建并编写实验代码exp.py，然后在run_exp.py中添加搜索路径即可。 最后，通过python3 ./run_exp.py 来开始实验。 exp.py是进行数据采集实验的脚本，主要流程为: 根据topo文件加载网络拓扑结构 配置业务流，干扰流的参数，包括数量，吞吐量，运行时间等 创建传输流，对tx进行指令下发 启动控制器(Solver端) 启动通信进程(通过start_comm_process实现)，接收回传的统计数据以及结果文件 分析数据并进行可视化处理(可选) 以下是一个简单的exp.py实验脚本的示例，用来根据topo文件构建链路并控制STA1向STA2发送文件数据流： 1234567891011121314151617import util.ctl as ctlfrom tools.read_graph import construct_graph## Create Linktopo, links = construct_graph(&quot;./config/topo/lo.txt&quot;)ip_table = ctl._ip_extract_all(topo)ctl._ip_associate(topo, ip_table)## Create Streamtemp = stream.stream()temp = temp.read_from_manifest(&#x27;./config/stream/file.json&#x27;)topo.ADD_STREAM(trans_manifest[&#x27;link&#x27;], temp, validate = False)## Start Transmissionconn = ctl.start_transmission(graph = topo, DURATION = 100)thrus = ctl.read_thu( conn )print(thrus) 注意事项对于每次实验： 自行配置当天的拓扑文件 修改exp.py中的date变量，并在exp.py新建启动函数 在dpScript按实验日期新建数据目录 4. Solver端4.1 FunctionSolver是使用rust编写的控制端程序，主要功能为： 收集与回传数据： 使用qos_collect接收受控设备回传的统计数据(例如rtt,channel_rtt,tx_part),简单处理格式后回传给监控端(monitor) 决策生成与控制： 根据接收到的统计数据以及决策算法进行决策(相关决策算法位于./cores目录)，生成action command,将控制命令发送给受控设备 4.2 Structure目录 /solver 结构如下所示： 12345678910111213141516171819202122232425262728.├── Cargo.lock├── Cargo.toml└── src ├── api │ ├── ipc.rs │ └── mod.rs ├── cores │ ├── back_switch_solver.rs │ ├── channel_balancer.rs │ ├── checker.rs │ ├── file_restrict.rs │ ├── forward_switch_solver.rs │ ├── green_solver.rs │ ├── mod.rs │ └── prediction.rs ├── lib.rs ├── tests │ ├── mod.rs │ ├── test_ipc.rs │ └── test_prediction.rs └── types ├── action.rs ├── mod.rs ├── parameter.rs ├── qos.rs ├── state.rs └── static_value.rs solver可以通过以下指令编译： 12cd ./solvercargo build --release 4.3 Solver详解以下来说明Solver各个子目录的功能： ./api ：子文件为ipc.rs，定义了负责和单个受控设备通信的结构体ipc_controller以及和多个受控设备通信的结构体ipc_Manager，包括了一系列收集数据、发送指令的方法 ./cores：该目录定义了一系列根据统计数据生成动作的决策方法。主进程根据实时统计数据在./cores中进行不同的的算法选择。决策实现如下： 文件 决策方法 back_switch_solver.rs BackSwitchSolver file_restrict.rs FileSolver green_solver.rs GSolver prediction.rs 定义了一系列线性回归的方法，被以上三个方法调用 ./types：该目录定义了一系列必要的数据结构和参数，其中， parameter.rs 定义了Solver的超参数。 ./tests：该目录定义了一系列测试用例，分别对ipc和线性回归函数进行测试。 Hyper Parameter12345678910111213141516171819202122pub struct HyperParameter&lt;&#x27;a&gt; &#123; pub throttle_low: f64, pub throttle_high: f64, pub backward_threshold: f64, pub epsilon_rtt: f64, pub scale_factor: f64, pub degration_threshold: f64, pub degration_tx_part_threshold: f64, pub wait_slots: usize, pub maximum_his_len: usize, pub ports_tobe_pop: [&amp;&#x27;a str; 3], pub running_duration: usize, pub ctl_time: usize, pub his_back_time: usize, pub back_off_rtt_threshold_factor: f64, // Threshold used to determine the reference backoff time pub balance_channel_rtt_thres: f64, pub balance_time_thres: usize, pub balance_tx_part_thres: f64, pub balance_rtt_thres: f64,&#125; throttle_low 和 throttle_high 分别是节流值throttle的下限和上限。 backward_threshold 是一个范围在 0 到 1 之间的阈值比例，用于确定信道是否可以开始切换回单信道模式。具体来说，更高的值意味着更激进的切换。 epsilon_rtt 是用于确定信道是否平衡的 RTT 差值的阈值。 scale_factor 是用于调整两个信道之间数据tx_part的缩放因子。 degration_threshold 是用于确定信道是否退化的 RTT 差值的阈值。 degration_tx_part_threshold 是用于确定信道是否退化的tx_part的阈值。 wait_slots 是在Solver开始调整tx_part之前需要等待的时隙数量。 maximum_his_len 是Solver历史记录的最大长度。 ports_tobe_pop 是待移除的端口，即这些端口不受控制。 running_duration 是Solver的运行时长。 ctl_time 是Solver开始控制的时间。 his_back_time 是用于确定信道是否曾经处于双信道模式的Solver历史的时间间隔。时间间隔越长，Solver从单信道模式切换到双信道模式就越保守。 back_off_rtt_threshold_factor 是用于确定参考回退时间的阈值，即该因子越低，回退越不可能发生。 balance_channel_rtt_thres 是 RTT 差值的最大阈值。如果信道的 RTT 大于此阈值，Solver将选择最大变化步长或决定执行基于线性拟合的控制。 balance_time_thres 是用于确定信道是否平衡的历史时间间隔。 balance_tx_part_thres 是tx_part的阈值。只有当tx_part大于此阈值时，这些历史记录才会用于基于线性拟合的控制。 balance_rtt_thres 是 RTT 差值的阈值。只有当 RTT 差值大于此阈值时，这些历史记录才会用于基于线性拟合的控制。 4.4 用法Solver的运行状态高度依赖于以上的超参数集，超参数可以通过设置HYPER_PARAMETER。 使用这种方法启动控制器时必须指定以下命令行参数： target-ips:link_name(tos@port)到链路ipc地址(ip:ipc_port)的映射 name2ipc：stream_name(tos@port)到link_name(wlan_PC_phone)的映射 base-info:所有stream的配置信息 monitor-ip：监控端的ip地址 Solver可以通过构建命令行字符串+subprocess启动，但是一般通过监控脚本exp.py调用conn.batch()的形式启动，如以下代码所示： 123456789101112import base64from tap import Connectorconn=Connector()conn.batch(control, &quot;control-info&quot;, &#123; &quot;target-ips&quot; : base64.b64encode( json.dumps(target_ips).encode() ).decode(), &quot;name2ipc&quot; : base64.b64encode( json.dumps(name2ipc).encode() ).decode(), &quot;base-info&quot; : base64.b64encode( json.dumps(base_info).encode() ).decode(), &quot;monitor-ip&quot; : monitor_ip, &#125;).wait(0.5).apply() NOTICE：Solver可以在监控设备所在子网内的任何设备上运行，命令行参数中，监控设备的 IP 地址moniter-ip应为监控设备无线网卡的 IP 地址，该地址对应的监控设备显示Solver结果的绘图。 5. Stream-Replay传输系统简介Stream-Replay是一个数据传输系统，包括tx端（数据发送端）和rx端（数据接收端），用于模拟真实网络环境下的wifi传输 5.1 Requirements Rust toolchain Python3, numpy 5.2 特性 根据*.npy文件生成UDP stream. 可以通过改变manifest.json 文件参数实现改变stream的配置. 以下是一个manifest.json的示例： 12345678910111213141516171819&#123; &quot;use_agg_socket&quot;: false, &quot;orchestrator&quot;: &quot;&quot;, &quot;window_size&quot;: 1000, &quot;streams&quot;:[ &#123; &quot;type&quot;:&quot;UDP&quot;, &quot;npy_file&quot;: &quot;data/temp.npy&quot;, &quot;port&quot;: 12345, &quot;duration&quot;: [0.0, 10.0], &quot;tos&quot;: 0, &quot;throttle&quot;: 0, &quot;priority&quot;: &quot;&quot;, &quot;calc_rtt&quot;: true, &quot;no_logging&quot;: false &#125; ]&#125; 支持 IPC（进程间通信）以实现对网络的实时监控和控制。 5.3 用法可以通过以下指令编译运行TX和RX端程序 Tx: 1cargo run --bin stream-replay &lt;manifest_file&gt; &lt;target_ip_address&gt; &lt;duration&gt; [--ipc-port &lt;IPC_PORT&gt;] Rx: 1cargo run --bin stream-replay-rx &lt;port&gt; &lt;duration&gt; [calc-rtt] 5.4 数据实时图Stream-Replay系统对多个live stream进行IPC节流控制(throttle contorl)，并获得RTT数据反馈 6 TX端6.1 简介TX端是数据传输实验的发射端，功能包括： 向RX端传输数据 接受Solver端发来的tx_part,throttle调度 向Solver端回传平均rtt等统计数据 6.2 文件结构 src&#x2F; statistic&#x2F; mod.rs rtt_records.rs broker.rs conf.rs dispatcher.rs ipc.rs lib.rs link.rs main.rs rtt.rs source.rs throttle.rs tx_part_ctl.rs Cargo.toml 6.3 主要文件介绍statistic/rtt_recoder.rs 实现了RTT的记录与管理功能 结构 定义了单条RTT记录结构RTTEntry以及管理多条RTTEntry的结构RTTRecord 函数 实现了statistic方法用于计算当前设备的平均RTT及信道平均RTT等参数 rtt.rs 实现了RTT数据的记录与管理 结构 定义了管理RTT测量记录的结构体RttRecorder，包含rtt_records、端口、服务名称，以及维护记录线程和接收线程 函数 定义了线程函数record_thread，负责记录发送包的序列号 定义了线程函数pong_recv_thread，负责接收ACK并计算RTT，将结果记录至rtt_records及日志文件 conf.rs 实现了发射流参数的配置管理 结构 定义了单条流发射配置结构体StreamParams 定义了管理TX端全局发射配置的结构体Manifest，该结构由所有StreamParams集合及其他配置参数组成 函数-实现了对配置合法性进行校验的方法conf::validate dispatcher.rs 实现了网络数据包的分发逻辑，为每个链路创建了数据发送通道 函数 定义了分发器函数dispatch()，为多个网络链路创建UDPsocket，并通过socket_thread()为每条链路创建独立发送线程，返回将tx_ipaddr映射至发送通道(flume::Sender&lt;PacketStruct&gt;)的哈希表，并为数据发送socket设置了防阻塞机制 link.rs 实现了网络链路配置管理 结构 定义了数据结构Link，存储tx端和rx端的IP地址，并实现其反序列化trait source.rs 实现了流数据的管理与传输 结构 定义了流管理器SourceManager 函数 实现方法start()用于开始数据传输 实现方法set_tx_parts()用于接受控制指令 实现方法Statistic()用于收集统计数据 以上三个方法用于响应Solver端的控制指令 定义了线程函数stream_thread，模拟实时数据发送（如投屏流） 定义了线程函数source_thread，处理预定义静态数据发送（如文件流） SourceManager::start根据npy文件协议头选择并启动相应线程 ipc.rs 实现了tx端的IPC通信机制 结构 定义了IPC守护进程IPCDaemon，负责处理来自其他进程的请求并返回结果 函数 handle_requests方法接收请求并根据枚举类型处理，目前支持Solver的三类请求：throttle调节、tx_part调节、Statistics统计信息请求 start_loop方法启动IPC守护进程，监听Solver的请求 main.rs 实现了发送端主进程逻辑 结构 定义了命令行参数结构体ProgArgs，封装TX端运行所需参数，包括manifest配置文件路径、IPC守护进程循环时间duration及监听端口ipc_port 函数 定义了tx端的入口函数main()，该函数通过ProgArgs解析命令行参数并执行TX端流程： 读取manifest清单，构造StreamParam列表并启动发射线程 根据duration和ipc_port启动IPC守护进程，监听Solver请求 7 RX端7.1 简介RX端是数据传输实验的接收端，功能包括： 接收来自TX的数据包，并返回ACK 本地记录rtt和stuttering等统计数据 7.2 文件结构 src&#x2F; statistic&#x2F; mod.rs stuttering.rs destination.rs lib.rs main.rs record.rs Cargo.toml 7.3 主要文件介绍stuttering.rs 实现了ACK时间戳的记录以及抖动率的计算 结构 定义了Stutter结构来维护所有ACK packet的发送时间戳 函数 为Stutter实现了update方法来更新ACK时间戳,实现了get_stuttering方法来计算抖动率 record.rs 实现了数据包的记录，处理，以及接收状态的检查 结构 定义了对单个数据包进行记录的结构RecvRecord以及对全局数据进行记录的结构RecvData，后者以seq号为索引存储必要的RecvData 函数 RecvRecord::record实现了对数据包(packet)进行记录 RecvRecord::determine_complete负责对各个链路传输状态（传输完成情况）进行评估 RecvRecord::gather实现了对离散的packet进行聚合 destination.rs 实现了数据包接收逻辑，包括： 创建接受数据的udp socket，监听指定端口 接收数据包并存储到RecvData中 创建pong socket并发送ACK 数据包完整时进行数据重组 结构 定义了命令行参数结构体Args，包含了监听端口，持续时间等参数，用于设置接收线程recv_thread的工作状态 函数 定义了接收线程函数recv_thread，实现了rx端的接收数据逻辑，用于持续接收数据包。通过调用handle_rtt记录并处理rtt数据，调用send_ack向数据源发送ACK确认 main.rsmain函数是rx端的入口函数，实现了以下流程： 从命令行中提取参数，包括监听端口以及休眠间隔 开启接收线程destination::recv_thread 计算并记录丢包率，抖动率等数据","categories":[],"tags":[{"name":"通信","slug":"通信","permalink":"http://www.irisnote.xyz/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"通信原理基础--确定信号分析","slug":"通信原理基础","date":"2025-03-08T16:00:00.000Z","updated":"2025-03-25T01:50:40.972Z","comments":true,"path":"2025/03/09/通信原理基础/","permalink":"http://www.irisnote.xyz/2025/03/09/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Background本学期的通信原理课在介绍信号调制等概念的同时，出现了一些在信号与系统课程中未出现的概念，如谱密度，自相关函数，解析信号，复包络等等，以下对这些基础概念进行简单的总结。 本文仅讨论确定信号分析，包含以下内容： 能量谱密度 功率谱密度 自相关函数 解析信号与变换 ………. a.能量谱密度ESD能量信号总能量有限的信号，如脉冲信号 定义能量谱密度描述的是信号或者时间序列的能量如何随频率分布。其定义为信号频谱模的平方： 其中是的傅里叶变换。 意义可以用来刻画能量信号的能量在频率上的分布(帕斯瓦尔定理) b.功率谱密度上面能量谱密度的定义适用于能量集中在一个时间窗口附近的瞬变（脉冲状信号）；因此信号的傅里叶变换一般存在。对于持续存在的连续信号，如平稳过程，可能不存在傅里叶变换，就必须定义功率谱密度（PSD） 功率信号信号的总能量无限但平均功率有限，如周期信号或随机信号 定义不妨考虑其能量有限的时间截断函数： 设的总能量为在上的平均功率为：按a中方法计算代入上式，即得到表达式 可知功率谱密度： 看起来不是很好计算（） c.自相关函数定义 用来描述信号和其延迟时刻的版本的相似性。 对于功率信号，此内积不一定存在，可用以下方式定义自相关函数： 维纳-辛钦定理维纳-辛钦定理指出：宽平稳随机过程的功率谱密度是其自相关函数的傅里叶变换。自相关函数的傅里叶变换是相应的谱密度我们可以根据自相关函数来更加方便的求取谱密度。实际上，在部分教材中，谱密度就是定义为自相关函数的傅里叶变换。 d.解析信号希尔伯特变换pass 解析信号pass 复包络（等效基带信号）pass","categories":[],"tags":[{"name":"通信","slug":"通信","permalink":"http://www.irisnote.xyz/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"记录一次chmod导致的服务器崩溃","slug":"记录一次chmod导致的服务器崩溃","date":"2025-02-21T16:00:00.000Z","updated":"2025-03-25T01:51:16.372Z","comments":true,"path":"2025/02/22/记录一次chmod导致的服务器崩溃/","permalink":"http://www.irisnote.xyz/2025/02/22/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1chmod%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83/","excerpt":"","text":"背景笔者在用vscode ssh远程配置docker镜像源的时候尝试通过修改/etc/docker/daemon.json文件来添加镜像源，由于笔者没有进入root账户，在修改完毕后遇到了无写入权限的问题，于是笔者根据以往的经验尝试使用sudo chmod R 777 &lt;path&gt;来进行权限修改。由于笔者是linux小白，为了省事直接令path=/etc，即是执行了 sudo chmod R 777 /etc 这一下坏事了，&#x2F;etc下存在许多重要文件，他们依赖于特定权限工作。这个指令造成的影响包括但不限于： SSH服务无法正常启动 sudo命令无法正常初始化 network瘫痪，外部无法ping通 DNS服务错误，甚至无法解析外部链接进行工具下载 连ssh都登不上了，问题似乎有些棘手。 尝试笔者翻阅了stackoverflow，csdn等国内外论坛，发现主要的思路大体分为两种： 使用pkexec工具代替损坏的sudo进行权限设置。但是笔者的server上没有该工具也无法下载（见上文第四条影响）。而且受影响的目录和文件那么多，难道要一点点ls然后敲？总体来说大致的思路合理，但是槽点很多。笔者的解决方案大致采取了它的登录+权限修复模式，并结合实际进行改进。 准备一台正常的服务器，把此服务器的权限文件保存下来并传输到问题服务器上，问题服务器可以根据此文件重新设置权限。问题在于笔者没有多的服务器，而且毕竟是断了网的云服务器，不是物理机，如何传输也是问题。 解决方案在网上查找了大量资料后，我将问题分解为两步. stage1:VNC登录VNCVNC（Virtual Network Computing）登录是一种远程桌面访问技术，允许用户通过网络连接到另一台计算机的桌面环境，从而实现对远程计算机的控制和操作。 VNC登录root账号与SSH协议不同，VNC是一种不安全的协议，对于权限没有特别高的要求就能执行。恰恰如此，这种远程登陆方案能够方便的在权限混乱的情况下使用。笔者使用的腾讯云服务器提供了VNC登录，我们可以通过重置密码功能设置root账户的密码，确认后点击登录，我们就以root的身份登录上机器了。 stage2:遍历&#x2F;etc恢复权限接下来，我们可以采用find+chmod有条件的递归式恢复文件和目录至正常权限。废话不多说，命令如下： 1find /etc -type d -exec chmod 775 &#123;&#125; \\; &amp;&amp; find /etc -type f -exec chmod 600 &#123;&#125; \\; 作用是在/etc目录下递归的遍历所有文件和目录，并将文件的权限设置为600,将目录的权限设置为775。拷贝命令至命令行后回车即可。 输入命令后，笔者进行了ping, ssh等各种测试，最终判断服务器完全恢复正常。此方案应该也可用于恢复/etc以外的目录（如根目录/）的权限，不过笔者没有测试，不保证可行性，仅供参考。 收获Permission is a dangerous toy Using it carefully 学パロこいしちゃん@ののこ #piciv","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.irisnote.xyz/tags/linux/"}]},{"title":"原神--不朽的开放世界游戏","slug":"Test","date":"2025-02-20T03:20:38.000Z","updated":"2025-03-25T01:15:41.161Z","comments":true,"path":"2025/02/20/Test/","permalink":"http://www.irisnote.xyz/2025/02/20/Test/","excerpt":"","text":"🎮 你还在玩那些老掉牙的游戏吗？ 是时候跟上潮流了！《原神》——这款由米哈游倾力打造的开放世界冒险RPG，已经席卷全球，成为无数玩家心中的“神作”！💥 🌍 探索提瓦特大陆在这个广袤无垠的提瓦特大陆上，你将化身为“旅行者”，探索七大国度的神秘与壮丽。从蒙德的自由之风到璃月的古老传说，每一寸土地都充满了惊喜与挑战！🗺️ ⚔️ 独特的元素战斗系统体验前所未有的战斗快感！风、火、水、雷、冰、草、岩，七大元素交织，策略与操作并存，战斗不再是单调的砍砍砍，而是智慧与技巧的较量！ 🎭 丰富的角色阵容每一位角色都拥有独特的背景故事与技能设定。无论是可爱的可莉，还是帅气的钟离，总有一位能俘获你的心！💖 🎶 精美的画面与音乐堪称视觉与听觉的双重盛宴！每一帧都如壁纸般精美，每一首BGM都能让你沉浸其中，仿佛置身于一个真实的奇幻世界！ 📈 持续更新与活动《原神》不断推出新版本、新活动，保持游戏的新鲜感与活力！每一次更新都让玩家们翘首以盼，仿佛在追一部永不落幕的史诗巨作！📅 🚀 加入冒险之旅还在犹豫什么？赶快加入《原神》的大家庭，开启你的冒险之旅吧！提瓦特大陆的奇迹，等你来发现！🌟 #原神 #开放世界 #RPG #米哈游 #提瓦特大陆 #元素战斗 #角色扮演 #冒险 #游戏推荐","categories":[],"tags":[{"name":"扯淡","slug":"扯淡","permalink":"http://www.irisnote.xyz/tags/%E6%89%AF%E6%B7%A1/"}]}],"categories":[],"tags":[{"name":"通信","slug":"通信","permalink":"http://www.irisnote.xyz/tags/%E9%80%9A%E4%BF%A1/"},{"name":"linux","slug":"linux","permalink":"http://www.irisnote.xyz/tags/linux/"},{"name":"扯淡","slug":"扯淡","permalink":"http://www.irisnote.xyz/tags/%E6%89%AF%E6%B7%A1/"}]}